using CommandLine;
using CQS.Genome.Feature;
using CQS.Genome.Mapping;
using RCPA.Seq;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace CQS.Genome.SmallRNA
{
  public abstract class AbstractSmallRNACountProcessorOptions : AbstractCountProcessorOptions, ISmallRNACountProcessorOptions
  {
    public const double DEFAULT_MinimumOverlapPercentage = 0.9;
    public const int DEFAULT_MaxMismatchForLincRNA = 0;
    public const int DEFAULT_MinReadLengthForLincRNA = 20;
    public const int DEFAULT_TooShortReadLength = 20;

    public static readonly string[] DEFAULT_Offsets = new string[] { "0", "1", "2" };

    public AbstractSmallRNACountProcessorOptions()
    {
      this.MinimumOverlapPercentage = DEFAULT_MinimumOverlapPercentage;
      this.MaximumMismatchForLongRNA = DEFAULT_MaxMismatchForLincRNA;
      this.MinimumReadLengthForLongRNA = DEFAULT_MinReadLengthForLincRNA;
      this.MaximumNoPenaltyMutationCount = DEFAULT_MaximumNoPenaltyMutationCount;
      this.TooShortReadLength = DEFAULT_TooShortReadLength;
      this.OffsetStrings = DEFAULT_Offsets.ToList();
    }

    [OptionList('i', "inputFile", Required = true, MetaValue = "FILE", Separator = ',', HelpText = "Alignment sam/bam files")]
    public virtual IList<string> InputFiles { get; set; }

    [Option('g', "coordinateFile", Required = true, MetaValue = "FILE", HelpText = "Genome annotation coordinate file generated by smallrna_database function of cqstools in bed format")]
    public string CoordinateFile { get; set; }

    [Option('f', "coordinateFastaFile", Required = false, MetaValue = "FILE", HelpText = "Genome annotation coordinate fasta file")]
    public string FastaFile { get; set; }

    [Option('q', "fastqFile", Required = false, MetaValue = "FILE", HelpText = "Original fastq file")]
    public string FastqFile { get; set; }

    [OptionList("offsets", Required = false, Separator = ',', HelpText = "Allowed (prilority ordered) offsets from miRNA locus, default: 0,1,2")]
    public List<string> OffsetStrings { get; set; }

    public List<long> Offsets
    {
      get
      {
        return (from s in OffsetStrings
                select long.Parse(s)).ToList();
      }
    }

    [Option("min_overlap", DefaultValue = DEFAULT_MinimumOverlapPercentage, HelpText = "Minimum overlap percentage between region and read (0.0 indicates at least 1 base overlap)")]
    public double MinimumOverlapPercentage { get; set; }

    [Option("max_longrna_mismatch", DefaultValue = DEFAULT_MaxMismatchForLincRNA, HelpText = "Maximum mismatch allowed for read mapped to longRNA (lincRNA and rRNA from ncbi)")]
    public int MaximumMismatchForLongRNA { get; set; }

    [Option("min_longrna_read_length", DefaultValue = DEFAULT_MinReadLengthForLincRNA, HelpText = "Minimum sequence length allowed for read mapped to longRNA (lincRNA and rRNA from ncbi)")]
    public int MinimumReadLengthForLongRNA { get; set; }

    [Option("not_overwrite", DefaultValue = false, HelpText = "Don't overwrite existing result files")]
    public bool NotOverwrite { get; set; }

    [Option("too_short_read_length", DefaultValue = DEFAULT_TooShortReadLength, HelpText = "The reads less than this number will be treated as too short if it's not mapped to smallRNA")]
    public int TooShortReadLength { get; set; }

    [Option("excludeXml", HelpText = "Exclude query in count xml file")]
    public string ExcludeXml { get; set; }

    public override bool PrepareOptions()
    {
      var result = base.PrepareOptions();

      long value;
      if (OffsetStrings.Any(l => !long.TryParse(l, out value)))
      {
        ParsingErrors.Add(string.Format("Offsets error {0}.", OffsetStrings.Merge(",")));
      }

      foreach (var file in this.InputFiles)
      {
        if (!File.Exists(file))
        {
          ParsingErrors.Add(string.Format("Input file not exists {0}.", file));
        }
      }

      if (!File.Exists(this.CoordinateFile))
      {
        ParsingErrors.Add(string.Format("Coordinate file not exists {0}.", this.CoordinateFile));
      }

      if (!string.IsNullOrEmpty(this.FastaFile) && !File.Exists(this.FastaFile))
      {
        ParsingErrors.Add(string.Format("Fasta file not exists {0}.", this.FastaFile));
      }

      if (!string.IsNullOrEmpty(this.ExcludeXml) && !File.Exists(this.ExcludeXml))
      {
        ParsingErrors.Add(string.Format("Exclude xml file not exists {0}.", this.ExcludeXml));
      }

      if (!string.IsNullOrEmpty(this.FastqFile) && !File.Exists(this.FastqFile))
      {
        ParsingErrors.Add(string.Format("Fastq file not exists {0}.", this.FastqFile));
      }

      if (this.OffsetStrings == null || this.OffsetStrings.Count == 0)
      {
        this.OffsetStrings = DEFAULT_Offsets.ToList();
      }

      return result && ParsingErrors.Count == 0;
    }

    private SmallRNACountMap cm;

    public override SmallRNACountMap GetCountMap()
    {
      if (cm == null)
      {
        cm = new SmallRNACountMap(this.CountFile);
        var keys = cm.Counts.Keys.Where(m => m.Contains(SmallRNAConsts.NTA_TAG)).ToArray();
        foreach (var key in keys)
        {
          var purekey = key.StringBefore(SmallRNAConsts.NTA_TAG);
          cm.Counts[purekey] = cm.Counts[key];
        }
      }
      return cm;
    }

    public virtual List<FeatureLocation> GetSequenceRegions()
    {
      //Read sequence regions
      var items = SequenceRegionUtils.GetSequenceRegions(CoordinateFile);
      items.ForEach(m =>
      {
        if (m.Seqname.StartsWith("chr"))
        {
          m.Seqname = m.Seqname.StringAfter("chr");
        }
      });

      //Fill sequence information, only miRNA and tRNA will be filled.
      if (!string.IsNullOrEmpty(this.FastaFile))
      {
        Console.WriteLine("Reading sequence from {0} ...", this.FastaFile);
        var seqs = SequenceUtils.Read(new FastaFormat(), this.FastaFile).ToDictionary(m => m.Name);
        items.ForEach(m =>
        {
          if (m.Name.StartsWith(SmallRNAConsts.miRNA) || m.Name.StartsWith(SmallRNAConsts.tRNA))
          {
            if (seqs.ContainsKey(m.Name))
            {
              m.Sequence = seqs[m.Name].SeqString;
            }
            else
            {
              Console.WriteLine("Missing sequence: " + m.Name);
            }
          }
          else
          {
            m.Sequence = string.Empty;
          }
        });
        seqs.Clear();
      }

      var result = items.ConvertAll(m => new FeatureLocation(m)).ToList();
      result.ForEach(m =>
      {
        m.Category = "";
        foreach (var categoryName in SmallRNAConsts.Biotypes)
        {
          if (m.Name.StartsWith(categoryName))
          {
            m.Category = categoryName;
          }
        }
      });

      if(result.All( l => l.Category.Equals("")))
      {
        var nocategories = result.Where(l => l.Category.Equals("")).ToList();
        throw new Exception(string.Format("There are no category assigned to all {0} regions based on name, such as {1}, check your coordinate file {2}", nocategories.Count, nocategories[0].Name, CoordinateFile));
      }

      return result;
    }
  }
}
